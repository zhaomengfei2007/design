package com.strategy;
/*
 * 策略模式(Strategy)
 * 把一个类中经常改变或者将来可能改变的部分提取出来，作为一个接口，然后在类中包含这个对象的实例，这样类的实例在运行时
 * 就可以随意调用实现了这个接口的类的行为。比如定义一系列的算法,把每一个算法封装起来, 并且使它们可相互替换，使得算法
 * 可独立于使用它的客户而变化。
 * 
 * 适用情况：
 * 许多相关的类仅仅是行为有异。 策略提供了一种用多个行为中的一个行为来配置一个类的方法。即一个系统需要动态地在几种算法中选择一种。
 * 当一个应用程序需要实现一种特定的服务或者功能，而且该程序有多种实现方式时使用。
 * 一个类定义了多种行为 , 并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的Strategy类中以代替这些条件语句。
 * 
 * 角色：
 * 环境类(Context):用一个ConcreteStrategy对象来配置。维护一个对Strategy对象的引用。可定义一个接口来让Strategy访问它的数据。
 * 抽象策略类(Strategy):定义所有支持的算法的公共接口。Context使用这个接口来调用某ConcreteStrategy定义的算法。
 * 具体策略类(ConcreteStrategy):以Strategy接口实现某具体算法。
 */
public interface IStrategy {
	public void operate();
}
/*
 * 优点：
 * （1）可以动态的改变对象的行为
 * 
 * 缺点：
 * （1）客户端必须知道所有的策略类，并自行决定使用哪一个策略类
 * （2）策略模式将造成产生很多策略类
 * 
 * 
 * 
 * 
 */